// Code generated by pggen. DO NOT EDIT.

package queries

import (
	"context"
	"fmt"
	"github.com/jackc/pgconn"
)

const createMessagesSQL = `WITH new_messages AS (
    INSERT INTO webhooks.message (
        application_id,
        event_type_id,
        event_id,
        payload
    ) SELECT 
        a.id,
        e.id,
        u.event_id,
        u.payload
    FROM unnest($1::webhooks.new_message[]) u
    JOIN webhooks.application a ON u.application_id = a.uid
    JOIN webhooks.event_type e ON u.event_type_id = e.uid
    ON CONFLICT DO NOTHING
    RETURNING 
        id,
        application_id,
        event_type_id,
        uid,
        created_at,
        event_id,
        payload
), new_attempts AS (
    INSERT INTO webhooks.message_attempt (
        uid,
        endpoint_id,
        message_id
    ) SELECT
        generate_ulid(),
        e.id,
        n.id
    FROM new_messages n
    INNER JOIN webhooks.endpoint_filter f 
        ON f.event_type_id = n.event_type_id
    INNER JOIN webhooks.endpoint e 
        ON e.id = f.endpoint_id 
            AND e.application_id = n.application_id
    RETURNING 
        id,
        uid, 
        endpoint_id,
        message_id,
        created_at,
        updated_at,
        retry,
        status,
        response_status,
        response
) SELECT ((
        id,
        application_id,
        event_type_id,
        uid,
        created_at,
        event_id,
        payload
    )::webhooks.message,
    (SELECT ARRAY_AGG(a::webhooks.message_attempt) FROM new_attempts a WHERE id = a.message_id)
)::webhooks.message_details FROM new_messages;`

// CreateMessages implements Querier.CreateMessages.
func (q *DBQuerier) CreateMessages(ctx context.Context, messages []NewMessage) ([]MessageDetails, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CreateMessages")
	rows, err := q.conn.Query(ctx, createMessagesSQL, q.types.newNewMessageArrayInit(messages))
	if err != nil {
		return nil, fmt.Errorf("query CreateMessages: %w", err)
	}
	defer rows.Close()
	items := []MessageDetails{}
	rowRow := q.types.newMessageDetails()
	for rows.Next() {
		var item MessageDetails
		if err := rows.Scan(rowRow); err != nil {
			return nil, fmt.Errorf("scan CreateMessages row: %w", err)
		}
		if err := rowRow.AssignTo(&item); err != nil {
			return nil, fmt.Errorf("assign CreateMessages row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close CreateMessages rows: %w", err)
	}
	return items, err
}

const deleteMessagesSQL = `DELETE FROM webhooks.message WHERE uid = ANY($1::UUID[]);`

// DeleteMessages implements Querier.DeleteMessages.
func (q *DBQuerier) DeleteMessages(ctx context.Context, ids []string) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteMessages")
	cmdTag, err := q.conn.Exec(ctx, deleteMessagesSQL, ids)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteMessages: %w", err)
	}
	return cmdTag, err
}

const getMessagesSQL = `SELECT ((
        id,
        application_id,
        event_type_id,
        uid,
        created_at,
        event_id,
        payload
    )::webhooks.message,
    (SELECT ARRAY_AGG(a::webhooks.message_attempt) FROM webhooks.message_attempt a WHERE id = a.message_id)
)::webhooks.message_details FROM webhooks.message
WHERE uid = ANY($1::uuid[]);`

// GetMessages implements Querier.GetMessages.
func (q *DBQuerier) GetMessages(ctx context.Context, ids []string) ([]MessageDetails, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetMessages")
	rows, err := q.conn.Query(ctx, getMessagesSQL, ids)
	if err != nil {
		return nil, fmt.Errorf("query GetMessages: %w", err)
	}
	defer rows.Close()
	items := []MessageDetails{}
	rowRow := q.types.newMessageDetails()
	for rows.Next() {
		var item MessageDetails
		if err := rows.Scan(rowRow); err != nil {
			return nil, fmt.Errorf("scan GetMessages row: %w", err)
		}
		if err := rowRow.AssignTo(&item); err != nil {
			return nil, fmt.Errorf("assign GetMessages row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close GetMessages rows: %w", err)
	}
	return items, err
}

const listMessagesSQL = `SELECT (
    id ,
    application_id ,
    event_type_id ,
    uid ,
    created_at,
    event_id,
    payload
)::webhooks.message
FROM webhooks.message
WHERE uid > $1
ORDER BY uid
LIMIT $2
OFFSET $3;`

type ListMessagesParams struct {
	After  string `json:"after"`
	Limit  int    `json:"limit"`
	Offset int    `json:"offset"`
}

// ListMessages implements Querier.ListMessages.
func (q *DBQuerier) ListMessages(ctx context.Context, params ListMessagesParams) ([]Message, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ListMessages")
	rows, err := q.conn.Query(ctx, listMessagesSQL, params.After, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query ListMessages: %w", err)
	}
	defer rows.Close()
	items := []Message{}
	rowRow := q.types.newMessage()
	for rows.Next() {
		var item Message
		if err := rows.Scan(rowRow); err != nil {
			return nil, fmt.Errorf("scan ListMessages row: %w", err)
		}
		if err := rowRow.AssignTo(&item); err != nil {
			return nil, fmt.Errorf("assign ListMessages row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListMessages rows: %w", err)
	}
	return items, err
}
