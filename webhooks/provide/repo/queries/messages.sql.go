// Code generated by pggen. DO NOT EDIT.

package queries

import (
	"context"
	"fmt"
	"github.com/jackc/pgconn"
)

const createMessagesSQL = `INSERT INTO webhooks.message (
    application_id,
    event_type_id,
    event_id,
    payload
) 
SELECT 
    a.id,
    e.id,
    u.event_id,
    u.payload
FROM unnest($1::webhooks.new_message[]) u
JOIN webhooks.application a ON u.application_id = a.uid
JOIN webhooks.event_type e ON u.event_type_id = e.uid
ON CONFLICT DO NOTHING
RETURNING (
    id ,
    application_id ,
    event_type_id ,
    uid ,
    created_at,
    event_id,
    payload
)::webhooks.message;`

// CreateMessages implements Querier.CreateMessages.
func (q *DBQuerier) CreateMessages(ctx context.Context, messages []NewMessage) ([]Message, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CreateMessages")
	rows, err := q.conn.Query(ctx, createMessagesSQL, q.types.newNewMessageArrayInit(messages))
	if err != nil {
		return nil, fmt.Errorf("query CreateMessages: %w", err)
	}
	defer rows.Close()
	items := []Message{}
	rowRow := q.types.newMessage()
	for rows.Next() {
		var item Message
		if err := rows.Scan(rowRow); err != nil {
			return nil, fmt.Errorf("scan CreateMessages row: %w", err)
		}
		if err := rowRow.AssignTo(&item); err != nil {
			return nil, fmt.Errorf("assign CreateMessages row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close CreateMessages rows: %w", err)
	}
	return items, err
}

const deleteMessagesSQL = `DELETE FROM webhooks.message WHERE uid = ANY($1::UUID[]);`

// DeleteMessages implements Querier.DeleteMessages.
func (q *DBQuerier) DeleteMessages(ctx context.Context, ids []string) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteMessages")
	cmdTag, err := q.conn.Exec(ctx, deleteMessagesSQL, ids)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteMessages: %w", err)
	}
	return cmdTag, err
}

const getMessagesSQL = `SELECT (
    id ,
    application_id ,
    event_type_id ,
    uid ,
    created_at,
    event_id,
    payload
)::webhooks.message
FROM webhooks.message
WHERE uid = ANY($1::uuid[]);`

// GetMessages implements Querier.GetMessages.
func (q *DBQuerier) GetMessages(ctx context.Context, ids []string) ([]Message, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetMessages")
	rows, err := q.conn.Query(ctx, getMessagesSQL, ids)
	if err != nil {
		return nil, fmt.Errorf("query GetMessages: %w", err)
	}
	defer rows.Close()
	items := []Message{}
	rowRow := q.types.newMessage()
	for rows.Next() {
		var item Message
		if err := rows.Scan(rowRow); err != nil {
			return nil, fmt.Errorf("scan GetMessages row: %w", err)
		}
		if err := rowRow.AssignTo(&item); err != nil {
			return nil, fmt.Errorf("assign GetMessages row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close GetMessages rows: %w", err)
	}
	return items, err
}

const listMessagesSQL = `SELECT (
    id ,
    application_id ,
    event_type_id ,
    uid ,
    created_at,
    event_id,
    payload
)::webhooks.message
FROM webhooks.message
ORDER BY uid
LIMIT $1
OFFSET $2;`

// ListMessages implements Querier.ListMessages.
func (q *DBQuerier) ListMessages(ctx context.Context, limit int, offset int) ([]Message, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ListMessages")
	rows, err := q.conn.Query(ctx, listMessagesSQL, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("query ListMessages: %w", err)
	}
	defer rows.Close()
	items := []Message{}
	rowRow := q.types.newMessage()
	for rows.Next() {
		var item Message
		if err := rows.Scan(rowRow); err != nil {
			return nil, fmt.Errorf("scan ListMessages row: %w", err)
		}
		if err := rowRow.AssignTo(&item); err != nil {
			return nil, fmt.Errorf("assign ListMessages row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListMessages rows: %w", err)
	}
	return items, err
}
