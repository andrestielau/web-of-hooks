// Code generated by pggen. DO NOT EDIT.

package queries

import (
	"context"
	"fmt"
	"github.com/jackc/pgconn"
	"time"
)

const setLastSeenSQL = `INSERT INTO webhooks.worker (
    id
) VALUES (
    $1
) ON CONFLICT(id)
    DO UPDATE SET 
        last_seen_at = now();`

// SetLastSeen implements Querier.SetLastSeen.
func (q *DBQuerier) SetLastSeen(ctx context.Context, id string) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "SetLastSeen")
	cmdTag, err := q.conn.Exec(ctx, setLastSeenSQL, id)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query SetLastSeen: %w", err)
	}
	return cmdTag, err
}

const dequeueAttemptsSQL = `WITH last_seen AS (
    INSERT INTO webhooks.worker (
        id
    ) VALUES (
        $1
    ) ON CONFLICT(id)
        DO UPDATE SET 
            last_seen_at = now()
), parts AS (
    SELECT 
        COUNT(*) as n, -- number of workers
        COUNT(first_seen_at < $2) as i -- number of workers that started before caller
    FROM webhooks.worker
    WHERE last_seen_at > now() - interval '10 second' -- exclude idle workers
), app_ids AS ( -- applications for worker
    SELECT 
        id 
    FROM webhooks.application, parts
    WHERE MOD(id, parts.n) = parts.i
), selected AS (
    SELECT 
        e.application_id,
        a.endpoint_id,
        a.message_id,
        a.id as attempt_id
    FROM webhooks.message_attempt a
    INNER JOIN webhooks.endpoint e
        ON a.endpoint_id = e.id
    WHERE (status = 0 OR 
        (status = 1 AND a.updated_at < now() - interval '10 second')) -- repick old messages 
        AND e.application_id IN (SELECT id FROM app_ids) -- damn sql, why cant it be just app_ids?
    LIMIT $3 
), dequeue AS (
    UPDATE webhooks.message_attempt a
    SET status = 1, updated_at = now()
    FROM selected s
    WHERE a.id = s.attempt_id
)
SELECT 
    application_id,
    endpoint_id,
    message_id,
    attempt_id
FROM selected;`

type DequeueAttemptsParams struct {
	ID    string    `json:"id"`
	Start time.Time `json:"start"`
	Limit int       `json:"limit"`
}

type DequeueAttemptsRow struct {
	ApplicationID *int32 `json:"application_id"`
	EndpointID    *int32 `json:"endpoint_id"`
	MessageID     *int32 `json:"message_id"`
	AttemptID     *int32 `json:"attempt_id"`
}

// DequeueAttempts implements Querier.DequeueAttempts.
func (q *DBQuerier) DequeueAttempts(ctx context.Context, params DequeueAttemptsParams) ([]DequeueAttemptsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DequeueAttempts")
	rows, err := q.conn.Query(ctx, dequeueAttemptsSQL, params.ID, params.Start, params.Limit)
	if err != nil {
		return nil, fmt.Errorf("query DequeueAttempts: %w", err)
	}
	defer rows.Close()
	items := []DequeueAttemptsRow{}
	for rows.Next() {
		var item DequeueAttemptsRow
		if err := rows.Scan(&item.ApplicationID, &item.EndpointID, &item.MessageID, &item.AttemptID); err != nil {
			return nil, fmt.Errorf("scan DequeueAttempts row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close DequeueAttempts rows: %w", err)
	}
	return items, err
}
