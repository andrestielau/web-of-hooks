// Code generated by pggen. DO NOT EDIT.

package queries

import (
	"context"
	"fmt"
	"github.com/jackc/pgconn"
)

const createEventTypesSQL = `INSERT INTO webhooks.event_type (
    key
) 
SELECT 
    u.key
FROM unnest($1::webhooks.new_event_type[]) u
ON CONFLICT DO NOTHING
RETURNING (
    id,
    key,
    uid,
    created_at
):: webhooks.event_type;`

// CreateEventTypes implements Querier.CreateEventTypes.
func (q *DBQuerier) CreateEventTypes(ctx context.Context, eventTypes []NewEventType) ([]EventType, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CreateEventTypes")
	rows, err := q.conn.Query(ctx, createEventTypesSQL, q.types.newNewEventTypeArrayInit(eventTypes))
	if err != nil {
		return nil, fmt.Errorf("query CreateEventTypes: %w", err)
	}
	defer rows.Close()
	items := []EventType{}
	rowRow := q.types.newEventType()
	for rows.Next() {
		var item EventType
		if err := rows.Scan(rowRow); err != nil {
			return nil, fmt.Errorf("scan CreateEventTypes row: %w", err)
		}
		if err := rowRow.AssignTo(&item); err != nil {
			return nil, fmt.Errorf("assign CreateEventTypes row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close CreateEventTypes rows: %w", err)
	}
	return items, err
}

const deleteEventTypesSQL = `DELETE FROM webhooks.event_type WHERE key = ANY($1::TEXT[]);`

// DeleteEventTypes implements Querier.DeleteEventTypes.
func (q *DBQuerier) DeleteEventTypes(ctx context.Context, keys []string) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteEventTypes")
	cmdTag, err := q.conn.Exec(ctx, deleteEventTypesSQL, keys)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteEventTypes: %w", err)
	}
	return cmdTag, err
}

const getEventTypesSQL = `SELECT (
    id,
    key,
    uid,
    created_at
):: webhooks.event_type
FROM webhooks.event_type
WHERE uid = ANY($1::uuid[]);`

// GetEventTypes implements Querier.GetEventTypes.
func (q *DBQuerier) GetEventTypes(ctx context.Context, ids []string) ([]EventType, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetEventTypes")
	rows, err := q.conn.Query(ctx, getEventTypesSQL, ids)
	if err != nil {
		return nil, fmt.Errorf("query GetEventTypes: %w", err)
	}
	defer rows.Close()
	items := []EventType{}
	rowRow := q.types.newEventType()
	for rows.Next() {
		var item EventType
		if err := rows.Scan(rowRow); err != nil {
			return nil, fmt.Errorf("scan GetEventTypes row: %w", err)
		}
		if err := rowRow.AssignTo(&item); err != nil {
			return nil, fmt.Errorf("assign GetEventTypes row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close GetEventTypes rows: %w", err)
	}
	return items, err
}

const listEventTypesSQL = `SELECT (
    id,
    key,
    uid,
    created_at
):: webhooks.event_type
FROM webhooks.event_type
WHERE uid > $1
ORDER BY uid
LIMIT $2
OFFSET $3;`

type ListEventTypesParams struct {
	After  string `json:"after"`
	Limit  int    `json:"limit"`
	Offset int    `json:"offset"`
}

// ListEventTypes implements Querier.ListEventTypes.
func (q *DBQuerier) ListEventTypes(ctx context.Context, params ListEventTypesParams) ([]EventType, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ListEventTypes")
	rows, err := q.conn.Query(ctx, listEventTypesSQL, params.After, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query ListEventTypes: %w", err)
	}
	defer rows.Close()
	items := []EventType{}
	rowRow := q.types.newEventType()
	for rows.Next() {
		var item EventType
		if err := rows.Scan(rowRow); err != nil {
			return nil, fmt.Errorf("scan ListEventTypes row: %w", err)
		}
		if err := rowRow.AssignTo(&item); err != nil {
			return nil, fmt.Errorf("assign ListEventTypes row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListEventTypes rows: %w", err)
	}
	return items, err
}
