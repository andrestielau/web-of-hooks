// Code generated by pggen. DO NOT EDIT.

package queries

import (
	"context"
	"fmt"
	"github.com/jackc/pgconn"
	"time"
)

const deleteAttemptsSQL = `DELETE FROM webhooks.message_attempt WHERE uid = ANY($1::UUID[]);`

// DeleteAttempts implements Querier.DeleteAttempts.
func (q *DBQuerier) DeleteAttempts(ctx context.Context, ids []string) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteAttempts")
	cmdTag, err := q.conn.Exec(ctx, deleteAttemptsSQL, ids)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteAttempts: %w", err)
	}
	return cmdTag, err
}

const getAttemptsSQL = `SELECT (
    id,
    uid,
    endpoint_id,
    message_id,
    created_at,
    updated_at,
    status,
    retry,
    response_status,
    response
)::webhooks.message_attempt
FROM webhooks.message_attempt
WHERE uid = ANY($1::uuid[]);`

// GetAttempts implements Querier.GetAttempts.
func (q *DBQuerier) GetAttempts(ctx context.Context, ids []string) ([]MessageAttempt, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetAttempts")
	rows, err := q.conn.Query(ctx, getAttemptsSQL, ids)
	if err != nil {
		return nil, fmt.Errorf("query GetAttempts: %w", err)
	}
	defer rows.Close()
	items := []MessageAttempt{}
	rowRow := q.types.newMessageAttempt()
	for rows.Next() {
		var item MessageAttempt
		if err := rows.Scan(rowRow); err != nil {
			return nil, fmt.Errorf("scan GetAttempts row: %w", err)
		}
		if err := rowRow.AssignTo(&item); err != nil {
			return nil, fmt.Errorf("assign GetAttempts row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close GetAttempts rows: %w", err)
	}
	return items, err
}

const listAttemptsSQL = `SELECT (
    id,
    uid,
    endpoint_id,
    message_id,
    created_at,
    updated_at,
    status,
    retry,
    response_status,
    response
)::webhooks.message_attempt
FROM webhooks.message_attempt
WHERE created_at > $1 
ORDER BY uid
LIMIT $2
OFFSET $3;`

type ListAttemptsParams struct {
	CreatedAfter time.Time `json:"created_after"`
	Limit        int       `json:"limit"`
	Offset       int       `json:"offset"`
}

// ListAttempts implements Querier.ListAttempts.
func (q *DBQuerier) ListAttempts(ctx context.Context, params ListAttemptsParams) ([]MessageAttempt, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ListAttempts")
	rows, err := q.conn.Query(ctx, listAttemptsSQL, params.CreatedAfter, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query ListAttempts: %w", err)
	}
	defer rows.Close()
	items := []MessageAttempt{}
	rowRow := q.types.newMessageAttempt()
	for rows.Next() {
		var item MessageAttempt
		if err := rows.Scan(rowRow); err != nil {
			return nil, fmt.Errorf("scan ListAttempts row: %w", err)
		}
		if err := rowRow.AssignTo(&item); err != nil {
			return nil, fmt.Errorf("assign ListAttempts row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListAttempts rows: %w", err)
	}
	return items, err
}
