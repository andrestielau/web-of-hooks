// Code generated by pggen. DO NOT EDIT.

package queries

import (
	"context"
	"fmt"
	"github.com/jackc/pgtype"
	"time"
)

const createEndpointsSQL = `INSERT INTO webhooks.endpoint (
    application_id,
    url,
    name,
    rate_limit,
    metadata,
    description
) 
SELECT 
    a.id,
    u.url,
    u.name,
    u.rate_limit,
    u.metadata,
    u.description
FROM unnest($1::webhooks.new_endpoint[]) u
JOIN webhooks.application a ON u.application_id = a.uid
ON CONFLICT DO NOTHING
RETURNING 
    id,
    uid,
        application_id,
    rate_limit,
    metadata,
    created_at;`

type CreateEndpointsRow struct {
	ID            int32        `json:"id"`
	Uid           string       `json:"uid"`
	ApplicationID int32        `json:"application_id"`
	RateLimit     int32        `json:"rate_limit"`
	Metadata      pgtype.JSONB `json:"metadata"`
	CreatedAt     time.Time    `json:"created_at"`
}

// CreateEndpoints implements Querier.CreateEndpoints.
func (q *DBQuerier) CreateEndpoints(ctx context.Context, endpoints []NewEndpoint) ([]CreateEndpointsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CreateEndpoints")
	rows, err := q.conn.Query(ctx, createEndpointsSQL, q.types.newNewEndpointArrayInit(endpoints))
	if err != nil {
		return nil, fmt.Errorf("query CreateEndpoints: %w", err)
	}
	defer rows.Close()
	items := []CreateEndpointsRow{}
	for rows.Next() {
		var item CreateEndpointsRow
		if err := rows.Scan(&item.ID, &item.Uid, &item.ApplicationID, &item.RateLimit, &item.Metadata, &item.CreatedAt); err != nil {
			return nil, fmt.Errorf("scan CreateEndpoints row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close CreateEndpoints rows: %w", err)
	}
	return items, err
}

const listEndpointsSQL = `SELECT 
    id,
    uid,
    url,
    name,
    metadata,
    disabled,
    rate_limit,
    created_at,
    updated_at,
    description,
    application_id
FROM webhooks.endpoint
ORDER BY uid
LIMIT $1
OFFSET $2;`

type ListEndpointsRow struct {
	ID            *int32       `json:"id"`
	Uid           string       `json:"uid"`
	Url           string       `json:"url"`
	Name          string       `json:"name"`
	Metadata      pgtype.JSONB `json:"metadata"`
	Disabled      *bool        `json:"disabled"`
	RateLimit     *int32       `json:"rate_limit"`
	CreatedAt     time.Time    `json:"created_at"`
	UpdatedAt     time.Time    `json:"updated_at"`
	Description   string       `json:"description"`
	ApplicationID *int32       `json:"application_id"`
}

// ListEndpoints implements Querier.ListEndpoints.
func (q *DBQuerier) ListEndpoints(ctx context.Context, limit int, offset int) ([]ListEndpointsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ListEndpoints")
	rows, err := q.conn.Query(ctx, listEndpointsSQL, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("query ListEndpoints: %w", err)
	}
	defer rows.Close()
	items := []ListEndpointsRow{}
	for rows.Next() {
		var item ListEndpointsRow
		if err := rows.Scan(&item.ID, &item.Uid, &item.Url, &item.Name, &item.Metadata, &item.Disabled, &item.RateLimit, &item.CreatedAt, &item.UpdatedAt, &item.Description, &item.ApplicationID); err != nil {
			return nil, fmt.Errorf("scan ListEndpoints row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListEndpoints rows: %w", err)
	}
	return items, err
}
