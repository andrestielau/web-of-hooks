// Code generated by pggen. DO NOT EDIT.

package queries

import (
	"context"
	"fmt"
	"github.com/jackc/pgconn"
)

const createEndpointsSQL = `INSERT INTO webhooks.endpoint (
    application_id,
    url,
    name,
    rate_limit,
    metadata,
    description
) 
SELECT 
    a.id,
    u.url,
    u.name,
    u.rate_limit,
    u.metadata,
    u.description
FROM unnest($1::webhooks.new_endpoint[]) u
JOIN webhooks.application a ON u.application_id = a.uid
RETURNING (
    id,
    url,
    name,
    application_id,
    uid,
    rate_limit,
    metadata,
    disabled,
    description,
    created_at,
    updated_at
)::webhooks.endpoint;`

// CreateEndpoints implements Querier.CreateEndpoints.
func (q *DBQuerier) CreateEndpoints(ctx context.Context, endpoints []NewEndpoint) ([]Endpoint, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CreateEndpoints")
	rows, err := q.conn.Query(ctx, createEndpointsSQL, q.types.newNewEndpointArrayInit(endpoints))
	if err != nil {
		return nil, fmt.Errorf("query CreateEndpoints: %w", err)
	}
	defer rows.Close()
	items := []Endpoint{}
	rowRow := q.types.newEndpoint()
	for rows.Next() {
		var item Endpoint
		if err := rows.Scan(rowRow); err != nil {
			return nil, fmt.Errorf("scan CreateEndpoints row: %w", err)
		}
		if err := rowRow.AssignTo(&item); err != nil {
			return nil, fmt.Errorf("assign CreateEndpoints row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close CreateEndpoints rows: %w", err)
	}
	return items, err
}

const deleteEndpointsSQL = `DELETE FROM webhooks.endpoint WHERE uid = ANY($1::UUID[]);`

// DeleteEndpoints implements Querier.DeleteEndpoints.
func (q *DBQuerier) DeleteEndpoints(ctx context.Context, ids []string) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteEndpoints")
	cmdTag, err := q.conn.Exec(ctx, deleteEndpointsSQL, ids)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteEndpoints: %w", err)
	}
	return cmdTag, err
}

const getEndpointsSQL = `SELECT (
    id,
    url,
    name,
    application_id,
    uid,
    rate_limit,
    metadata,
    disabled,
    description,
    created_at,
    updated_at
)::webhooks.endpoint
FROM webhooks.endpoint
WHERE uid = ANY($1::uuid[]);`

// GetEndpoints implements Querier.GetEndpoints.
func (q *DBQuerier) GetEndpoints(ctx context.Context, ids []string) ([]Endpoint, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetEndpoints")
	rows, err := q.conn.Query(ctx, getEndpointsSQL, ids)
	if err != nil {
		return nil, fmt.Errorf("query GetEndpoints: %w", err)
	}
	defer rows.Close()
	items := []Endpoint{}
	rowRow := q.types.newEndpoint()
	for rows.Next() {
		var item Endpoint
		if err := rows.Scan(rowRow); err != nil {
			return nil, fmt.Errorf("scan GetEndpoints row: %w", err)
		}
		if err := rowRow.AssignTo(&item); err != nil {
			return nil, fmt.Errorf("assign GetEndpoints row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close GetEndpoints rows: %w", err)
	}
	return items, err
}

const listEndpointsSQL = `SELECT (
    id,
    url,
    name,
    application_id,
    uid,
    rate_limit,
    metadata,
    disabled,
    description,
    created_at,
    updated_at
)::webhooks.endpoint
FROM webhooks.endpoint
WHERE uid > $1 
ORDER BY uid
LIMIT $2
OFFSET $3;`

type ListEndpointsParams struct {
	After  string `json:"after"`
	Limit  int    `json:"limit"`
	Offset int    `json:"offset"`
}

// ListEndpoints implements Querier.ListEndpoints.
func (q *DBQuerier) ListEndpoints(ctx context.Context, params ListEndpointsParams) ([]Endpoint, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ListEndpoints")
	rows, err := q.conn.Query(ctx, listEndpointsSQL, params.After, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query ListEndpoints: %w", err)
	}
	defer rows.Close()
	items := []Endpoint{}
	rowRow := q.types.newEndpoint()
	for rows.Next() {
		var item Endpoint
		if err := rows.Scan(rowRow); err != nil {
			return nil, fmt.Errorf("scan ListEndpoints row: %w", err)
		}
		if err := rowRow.AssignTo(&item); err != nil {
			return nil, fmt.Errorf("assign ListEndpoints row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListEndpoints rows: %w", err)
	}
	return items, err
}
